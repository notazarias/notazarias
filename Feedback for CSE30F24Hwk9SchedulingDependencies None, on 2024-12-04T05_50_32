{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e9b3c1bb",
   "metadata": {
    "id": "HfiFcAD_BDLs",
    "notebookgrader": {
     "id": "1adc77c9decfe867dd4cc5fa12b1ca446f44d389",
     "readonly": true
    }
   },
   "source": [
    "# Scheduling with Dependencies\n",
    "\n",
    "Copyright Luca de Alfaro, 2019-20.\n",
    "License: [CC-BY-NC-ND](https://creativecommons.org/licenses/by-nc-nd/4.0/)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "139767c7",
   "metadata": {
    "id": "FGuADojH4FzV",
    "notebookgrader": {
     "id": "553d2c82cb3f4a6579e4ebb21067eb38028b2b83",
     "readonly": true
    }
   },
   "source": [
    "Assume you have to prepare Pasta Carbonara.   My version of the recipe goes like this:\n",
    "\n",
    "> Dice onions and pancetta, and fry in a mix of olive oil and butter, slowly.  Separately, put in a bowl as many eggs as there are dinner guests; you can either put in the bowls the yolks only, or you can add a few whites if you wish.  Beat the eggs.  \n",
    "> Bring water to a boil, and when it boils, salt it.  Put the pasta in (I like Penne Rigate).   When cooked, colander the water away, and quickly unite in the bowl the beaten eggs, the pasta, and the pancetta.  Mix well and serve immediately.\n",
    "\n",
    "If you have to invite people over, you could do this recipe sequentially, and first worry about cooking the pasta: warming the water, putting the pasta in, then colandering it.  Then you could worry about cooking the pancetta and onions.  When that's done, you can start to beat the eggs. Finally, you could unite everything.  Technically, that would work, but there would be two problems.  The first is that, of course, the pasta would be rather cold by the time it would be served, a capital sin (pasta must be served immediately after it is cooked).  Secondly, even if you rehash the order so that you first cook the pancetta, then beat the eggs, then cook the pasta, then technically this works -- but it would take you well over one hour to have everything ready.  You want to do things in parallel, cooking the pancetta while heating up the water for the pasta, and so forth.  You want to discover what are the things that need to be done one after the other, and what are the things that can be done in parallel, and in which order to do everything.  \n",
    "\n",
    "Great cooking, by the way, is much about the perfect timing, not only the perfect preparation.  You have to have the various preparations ready at the same time, to unite them just right.  We will worry about timing in the second part of this chapter; first, we worry about what we can do and in which order.\n",
    "\n",
    "As an aside for those of you who are more interested in compiling code than in cooking, the problem of how to compile C or C++ code is very similar.  A makefile defines dependencies between tasks: you have to have compiled pathlib.c before you can link the result together with something else.  The task of the make program is to figure out how to parallelize the compilation, so that independent tasks can happen in different processes (possibly on different CPU cores), while respecting the precedence constraints between tasks.  We will mention this application in some of the exercises of the chapter.\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9917bcb",
   "metadata": {
    "id": "DXG3cQBZ9Z-i",
    "notebookgrader": {
     "id": "dab173597265035076ff7750ea74d293b5124e2b",
     "readonly": true
    }
   },
   "source": [
    "## Scheduling dependent tasks"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f15b8c08",
   "metadata": {
    "id": "MmXKWlX19fI_",
    "notebookgrader": {
     "id": "20aae1a45e3f4dde562e5155b87232ca97308a7c",
     "readonly": true
    }
   },
   "source": [
    "We first disregard the problem of cooking (or compiling) time, and ask about the order in which we should be doing the tasks.  We want to create a _Scheduler_ object, that can tell us what to do at the same time.  What operations should this object support?\n",
    "\n",
    "* **add_task:** we should be able to add a task, along with the task dependencies.\n",
    "* **reset:** indicating that we are about to run the sequences of tasks again.\n",
    "* **available_tasks:** this property should return the set of things that we can do in parallel.\n",
    "* **mark_completed:** used to notify the scheduler that we have completed a task.  This should return the set of new tasks that we can do due to this task being completed; we can do these tasks in parallel alongside with the others that we are already doing.\n",
    "* **all_done:** returns True/False according to whether we have completed all tasks.\n",
    "\n",
    "Choosing these operations is perhaps the most important step in the design of the scheduler.  The operations need to have a simple, clear definition, and be useful in a concrete implementation of the service which will run the tasks.  Of the above operations, they are all uncontroversial, except for the choice of behavior of _completed_.  In theory, there is no need for _completed_ to return the set of _new_ tasks that can now be undertaken.  If one remembers the set of tasks $T_1$ one can a do before a task $t \\in T_1$ is completed, and marks $t$ as completed, one can simply ask the scheduler for the set of tasks $T_2$ that can now be done, and add those in $T_{21t} = T_2 \\setminus (\\{t\\} \\cup T_1)$ for execution.  However, we guess (as we have not yet written the task execution engine) that being told this set of tasks directly will simplify the design of the task execution engine."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52455245",
   "metadata": {
    "id": "WHcjTU2yHVf3",
    "notebookgrader": {
     "id": "cc1f69d326c1d0677000c8b02798c1d3327cea8a",
     "readonly": true
    }
   },
   "source": [
    "We want to create a **DependencyScheduler** class, to be used as follows.\n",
    "\n",
    "We can create a scheduler, initially with no tasks:\n",
    "\n",
    "    ds = DependencyScheduler()\n",
    "\n",
    "Then, we want to add tasks, with their dependencies.\n",
    "\n",
    "    ds.add_task(a, [b, c])\n",
    "    ds.add_task(b, [c, d])\n",
    "\n",
    "Once the tasks are added, we say, ok, mark them all not yet done, and let's begin.\n",
    "\n",
    "    ds.reset()\n",
    "\n",
    "We want to ask for the set of tasks we can do, via:\n",
    "\n",
    "    ds.available_tasks\n",
    "\n",
    "and finally, we want to be able to say that we have completed a task, and get in response the set of _new_ tasks we can do:\n",
    "\n",
    "    ds.mark_completed(b)\n",
    "\n",
    "And of course, we want to be able to check if we have done everything!\n",
    "\n",
    "    ds.done"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a3679bed",
   "metadata": {
    "id": "7kmgWJOPJkzR",
    "notebookgrader": {
     "id": "6a2fc95bfc47f3731bd7c2a279948031c45419a6",
     "readonly": true
    }
   },
   "source": [
    "We will use the dependency scheduler like this:\n",
    "\n",
    "    ds = DependencyScheduler()\n",
    "    ds.add_task(a, [b, c])\n",
    "    ds.add_task(b, [c, d])\n",
    "    ds.reset()\n",
    "\n",
    "    available = ds.available_tasks()\n",
    "    while len(available) > 0:\n",
    "        task = available.pop()\n",
    "        available |= ds.mark_completed(task)\n",
    "    assert ds.done\n",
    "\n",
    "It's very useful to write mock code before writing the actual implementation!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a7177acb",
   "metadata": {
    "id": "RSwqbVObJWjP",
    "notebookgrader": {
     "id": "10db584a9185ca6ddc05773324eccbe9b793fbe6",
     "readonly": true
    }
   },
   "source": [
    "Our scheduler class will be implemented in similar fashion to our graph class, with tasks corresponding to graph vertices, and dependencies represented as edges.\n",
    "The difference is that here, given a vertex (that is, a task) $v$, it will be useful to be able to access both:\n",
    "\n",
    "* the _predecessors_ of $v$, that is, the tasks $u$ that are declared as prerequisites of $v$, and\n",
    "* the _successors_ of $v$, that is, the tasks $u$ such that $v$ was declared as a prerequisite for $u$.\n",
    "\n",
    "When we add a task, we would have to initialize its set of successors and predecessors to empty.  This is somewhat tedious, and so we resort to a defaultdict, which is a special type of dictionary such that, if the mapping for a key has not been defined, it returns a default value; in our case, an empty set.  [You can read more about defaultdict and related types here](https://docs.python.org/3.7/library/collections.html#collections.defaultdict).\n",
    "\n",
    "Our first implementation of the class is as follows.  We let you complete the `available_tasks` and `mark_completed` methods.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5e55a1c2",
   "metadata": {
    "executionInfo": {
     "elapsed": 128,
     "status": "ok",
     "timestamp": 1699916895987,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "fb77GvTM5mxK",
    "notebookgrader": {
     "id": "b57ff7c6bd7c5a0c059ddc6572e2b778fc333912",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from collections import defaultdict\n",
    "import networkx as nx # Library for displaying graphs.\n",
    "import matplotlib.pyplot as plt\n",
    "import random"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0ec3c6fa",
   "metadata": {
    "executionInfo": {
     "elapsed": 4,
     "status": "ok",
     "timestamp": 1699916895988,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "ae9A70cUlZyL",
    "notebookgrader": {
     "id": "5f0c6dc5080b4af19aef3539b325cfa70b8a1305",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class DependencyScheduler(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        self.tasks = set()\n",
    "        # The successors of a task are the tasks that depend on it, and can\n",
    "        # only be done once the task is completed.\n",
    "        self.successors = defaultdict(set)\n",
    "        # The predecessors of a task have to be done before the task.\n",
    "        self.predecessors = defaultdict(set)\n",
    "        self.completed_tasks = set() # completed tasks\n",
    "\n",
    "    def add_task(self, t, dependencies):\n",
    "        \"\"\"Adds a task t with given dependencies.\"\"\"\n",
    "        # Makes sure we know about all tasks mentioned.\n",
    "        assert t not in self.tasks or len(self.predecessors[t]) == 0, \"The task was already present.\"\n",
    "        self.tasks.add(t)\n",
    "        self.tasks.update(dependencies)\n",
    "        # The predecessors are the tasks that need to be done before.\n",
    "        self.predecessors[t] = set(dependencies)\n",
    "        # The new task is a successor of its dependencies.\n",
    "        for u in dependencies:\n",
    "            self.successors[u].add(t)\n",
    "\n",
    "    def reset(self):\n",
    "        self.completed_tasks = set()\n",
    "\n",
    "    @property\n",
    "    def done(self):\n",
    "        return self.completed_tasks == self.tasks\n",
    "\n",
    "    def show(self):\n",
    "        \"\"\"We use the nx graph to display the graph.\"\"\"\n",
    "        g = nx.DiGraph()\n",
    "        g.add_nodes_from(self.tasks)\n",
    "        g.add_edges_from([(u, v) for u in self.tasks for v in self.successors[u]])\n",
    "        node_colors = [('green' if v in self.completed_tasks\n",
    "                        else 'red' if v in self.available_tasks\n",
    "                        else 'gray')\n",
    "                        for v in self.tasks]\n",
    "        nx.draw(g, with_labels=True, node_color=node_colors)\n",
    "        plt.show()\n",
    "\n",
    "    @property\n",
    "    def uncompleted(self):\n",
    "        \"\"\"Returns the tasks that have not been completed.\n",
    "        This is a property, so you can say scheduler.uncompleted rather than\n",
    "        scheduler.uncompleted()\"\"\"\n",
    "        return self.tasks - self.completed_tasks\n",
    "\n",
    "    @property\n",
    "    def available_tasks(self):\n",
    "        \"\"\"Returns the available tasks.\n",
    "        This is just a placeholder; we will let you implement this.\"\"\"\n",
    "        return set()\n",
    "\n",
    "    def mark_completed(self, t):\n",
    "        \"\"\"Marks that the task t is completed, and returns the set of tasks\n",
    "        that become available as a consequence.\n",
    "        This is just a placeholder, we will let you implement this.\"\"\"\n",
    "        return set()\n",
    "\n",
    "    def _check(self):\n",
    "        \"\"\"We check that if t is a successor of u, then u is a predecessor\n",
    "        of t.\"\"\"\n",
    "        for u in self.tasks:\n",
    "            for t in self.successors[u]:\n",
    "                assert u in self.predecessors[t]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ff2fcdff",
   "metadata": {
    "id": "sGnXCPipfvWA",
    "notebookgrader": {
     "id": "9672cb5004fb50b67513876003e5569b38f9a9f6",
     "readonly": true
    }
   },
   "source": [
    "Here is the place where to implement `available_tasks` and `mark_completed`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "748039f7",
   "metadata": {
    "executionInfo": {
     "elapsed": 3,
     "status": "ok",
     "timestamp": 1733291386392,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "E5GmHSKlfiWH",
    "notebookgrader": {
     "id": "6a0c136b945b34a974d4dc27bfbb1dd33c0d6b86",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title Implementation of `available_tasks` and `mark_completed`.\n",
    "\n",
    "def scheduler_available_tasks(self):\n",
    "    \"\"\"Returns the set of tasks that can be done in parallel.\n",
    "    A task can be done if all its predecessors have been completed.\n",
    "    And of course, we don't return any task that has already been\n",
    "    completed.\"\"\"\n",
    "    ### YOUR SOLUTION HERE\n",
    "    hold = set()\n",
    "    for i in self.uncompleted:\n",
    "        if self.predecessors[i].issubset(self.completed_tasks):\n",
    "            hold.add(i)\n",
    "    return hold\n",
    "\n",
    "\n",
    "    # return {u for u in self.tasks\n",
    "    #         if self.predecessors[u].issubset(self.completed_tasks)}\n",
    "\n",
    "\n",
    "def scheduler_mark_completed(self, t):\n",
    "    \"\"\"Marks the task t as completed, and returns the additional\n",
    "    set of tasks that can be done (and that could not be\n",
    "    previously done) once t is completed.\"\"\"\n",
    "    ### YOUR SOLUTION HERE\n",
    "    hold = set()\n",
    "    self.completed_tasks.add(t)\n",
    "    for j in self.successors[t]:\n",
    "        if self.predecessors[j].issubset(self.completed_tasks):\n",
    "            hold.add(j)\n",
    "    return hold\n",
    "\n",
    "DependencyScheduler.available_tasks = property(scheduler_available_tasks)\n",
    "DependencyScheduler.mark_completed = scheduler_mark_completed\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6f01e007",
   "metadata": {
    "id": "uemd61_PP2AI",
    "notebookgrader": {
     "id": "150b93da92a521ce152be45c3cbe16a018496a0c",
     "readonly": true
    }
   },
   "source": [
    "Let us check if this works."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "372f5655",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 516
    },
    "executionInfo": {
     "elapsed": 297,
     "status": "ok",
     "timestamp": 1699916896282,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "NFvrVZJjP07w",
    "notebookgrader": {
     "id": "a01395ef99606fe4219d3cb86b698ef5fa36fbfb",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "e08a4d7b-79d3-45b9-c709-9b56fe7f690a"
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b', 'c'])\n",
    "s.add_task('b', ['c', 'e'])\n",
    "s._check()\n",
    "s.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8a954cee",
   "metadata": {
    "id": "hpzNVlI7QsWL",
    "notebookgrader": {
     "id": "f6b865f4cb47fc6dd5d3e74bdd2cb0625f731f8a",
     "readonly": true
    }
   },
   "source": [
    "We note that in the above drawing, the edges denote temporal succession, that is, an edge from $c$ to $a$ means that $c$ must happen before $a$.\n",
    "Let us execute the schedule manually."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d15a13e",
   "metadata": {
    "id": "vGpKak4Uzc6U",
    "notebookgrader": {
     "id": "2686bc2aaa3b08f8f90de0fda5ef2e47a4933740",
     "readonly": true
    }
   },
   "source": [
    "Here are some tests for `available_tasks` and `mark_completed`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "a2caf8fb",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 8,
     "status": "ok",
     "timestamp": 1699916896282,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "vMy3zi5gDg37",
    "notebookgrader": {
     "id": "32801e59358c64b173af61ea2d740c490790de4e",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: Simple tests.\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "assert s.available_tasks == {'a'}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "75b8358f",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 335,
     "status": "ok",
     "timestamp": 1699916896610,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "8Qlxj8OtzYN0",
    "notebookgrader": {
     "id": "b9ace8ca713d9a77164acad6fdc2407f0416e82a",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: Slightly more complicated.\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b', 'c'])\n",
    "s.add_task('b', ['c', 'e'])\n",
    "assert s.available_tasks == {'e', 'c'}\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b'])\n",
    "s.add_task('b', ['a'])\n",
    "assert s.available_tasks == set()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "83bd474f",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 336,
     "status": "ok",
     "timestamp": 1699916896611,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "1uRRJ3H2EkrN",
    "notebookgrader": {
     "id": "a841010ffdd04a287be39e3656fdb4ae4d3173d3",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: Now, let's test `mark_completed`.  Simple tests first.\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "assert s.available_tasks == {'a'}\n",
    "r = s.mark_completed('a')\n",
    "assert r == set()\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b'])\n",
    "assert s.available_tasks == {'b'}\n",
    "r = s.mark_completed('b')\n",
    "assert r == {'a'}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "2524768e",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 7,
     "status": "ok",
     "timestamp": 1699916896611,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "2C5xqJ7iHBSX",
    "notebookgrader": {
     "id": "f2523feb7a67849d9e6c9ca577650c4d44060cd9",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: Slightly more complicated.\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b', 'c'])\n",
    "assert s.available_tasks == {'b', 'c'}\n",
    "r = s.mark_completed('b')\n",
    "assert r == set()\n",
    "assert s.available_tasks == {'c'}\n",
    "r = s.mark_completed('c')\n",
    "assert r == {'a'}\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b', 'c'])\n",
    "s.add_task('b', ['c', 'e'])\n",
    "s.add_task('c', [])\n",
    "assert s.available_tasks == {'c', 'e'}\n",
    "r = s.mark_completed('e')\n",
    "assert r == set()\n",
    "r = s.mark_completed('c')\n",
    "assert r == {'b'}\n",
    "r = s.mark_completed('b')\n",
    "assert r == {'a'}\n",
    "r = s.mark_completed('a')\n",
    "assert r == set()\n",
    "assert s.available_tasks == set()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc10ac7b",
   "metadata": {
    "id": "doKGkVc9ErCT",
    "notebookgrader": {
     "id": "4c28c893f1c4f51f68f86a94aa211e7aa07a98e2",
     "readonly": true
    }
   },
   "source": [
    "## Executing the tasks\n",
    "\n",
    "Here is an execution engine for our tasks with dependencies."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "44cb0b42",
   "metadata": {
    "executionInfo": {
     "elapsed": 7,
     "status": "ok",
     "timestamp": 1699916896611,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "OloVGv-SQJZ5",
    "notebookgrader": {
     "id": "2021086f212caf4dace243a5d8712defbccb822c",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def execute_schedule(s, show=False):\n",
    "    s.reset()\n",
    "    in_process = s.available_tasks\n",
    "    print(\"Starting by doing:\", in_process)\n",
    "    while len(in_process) > 0:\n",
    "        # Picks one random task to be the first to be completed.\n",
    "        t = random.choice(list(in_process))\n",
    "        print(\"Completed:\", t)\n",
    "        in_process = in_process - {t} | s.mark_completed(t)\n",
    "        print(\"Now doing:\", in_process)\n",
    "        if show:\n",
    "            s.show()\n",
    "    # Have we done all?\n",
    "    if not s.done:\n",
    "        print(\"Error, there are tasks that could not be completed:\", s.uncompleted)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c70dfc4",
   "metadata": {
    "id": "qvSL08YNM9Td",
    "notebookgrader": {
     "id": "cb568cf8876aa80bc69a5773dd4579a447323248",
     "readonly": true
    }
   },
   "source": [
    "Let's try it on our old schedule:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "ecaae9ac",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 516
    },
    "executionInfo": {
     "elapsed": 7,
     "status": "ok",
     "timestamp": 1699916896611,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "ShRsgs64M7Md",
    "notebookgrader": {
     "id": "6a819815ea1758dfd239f957a3a4bf2ec637612e",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "7b33669a-10ce-40e0-a454-2f0207ca32f1"
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b', 'c'])\n",
    "s.add_task('b', ['c', 'e'])\n",
    "s._check()\n",
    "s.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "54732599",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1000
    },
    "executionInfo": {
     "elapsed": 810,
     "status": "ok",
     "timestamp": 1699916897416,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "3LpweoftSHrN",
    "notebookgrader": {
     "id": "5fd7633503d681bd9cb3656d3cbeb09324f00711",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "5a4fe79e-94b0-4da0-8cc1-0a060ee84259"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Starting by doing: {'e', 'c'}\n",
       "Completed: e\n",
       "Now doing: {'c'}\n",
       "Completed: c\n",
       "Now doing: {'b'}\n",
       "Completed: b\n",
       "Now doing: {'a'}\n",
       "Completed: a\n",
       "Now doing: set()"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "execute_schedule(s, show=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "425e1f3f",
   "metadata": {
    "id": "x0pB2UWAUqsV",
    "notebookgrader": {
     "id": "27582b35d1f40493ee474fc8df428fde01045151",
     "readonly": true
    }
   },
   "source": [
    "What happens if there is a loop?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "55bd8c1d",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 5,
     "status": "ok",
     "timestamp": 1699916897416,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "2QWMPWVPSJoO",
    "notebookgrader": {
     "id": "03438db6ae60562bd9c608a85a39c1cd8b03ed61",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "57150f1c-1941-4ccd-c6fb-2199518eba76"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Starting by doing: set()\n",
       "Error, there are tasks that could not be completed: {'c', 'b', 'a'}"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "s = DependencyScheduler()\n",
    "s.add_task('a', ['b'])\n",
    "s.add_task('b', ['a'])\n",
    "s.add_task('c', ['a'])\n",
    "execute_schedule(s)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "421f0459",
   "metadata": {
    "id": "qTMg4D0VVK5y",
    "notebookgrader": {
     "id": "0f51cb693d78a16a33c83526cb7312eeb41c5744",
     "readonly": true
    }
   },
   "source": [
    "Ok, this is reasonable!  Let us now encode our Carbonara pasta recipe."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "baf84c00",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 516
    },
    "executionInfo": {
     "elapsed": 389,
     "status": "ok",
     "timestamp": 1699916897803,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "pJkJpBhoU8DP",
    "notebookgrader": {
     "id": "b3bc02dc5dd5242ab020e0744bc053858d25995e",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "fdfe9e63-4d9d-487f-f5ac-18f9a5c8c6ff"
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "carbonara = DependencyScheduler()\n",
    "\n",
    "# First, the part about cooking the pancetta.\n",
    "carbonara.add_task('dice onions', [])\n",
    "carbonara.add_task('dice pancetta', [])\n",
    "carbonara.add_task('put oil and butter in pan', [])\n",
    "carbonara.add_task('put pancetta in pan', ['dice pancetta'])\n",
    "carbonara.add_task('put onions in pan', ['dice onions'])\n",
    "carbonara.add_task('cook pancetta', ['put oil and butter in pan',\n",
    "                                     'put pancetta in pan',\n",
    "                                     'put onions in pan'])\n",
    "\n",
    "# Second, the part about beating the eggs.\n",
    "carbonara.add_task('put eggs in bowl', [])\n",
    "carbonara.add_task('beat eggs', ['put eggs in bowl'])\n",
    "\n",
    "# Third, cooking the pasta.\n",
    "carbonara.add_task('fill pot with water', [])\n",
    "carbonara.add_task('bring pot of water to a boil', ['fill pot with water'])\n",
    "carbonara.add_task('add salt to water', ['bring pot of water to a boil'])\n",
    "carbonara.add_task('put pasta in water', ['bring pot of water to a boil',\n",
    "                                         'add salt to water'])\n",
    "carbonara.add_task('colander pasta', ['put pasta in water'])\n",
    "\n",
    "# And finally, we can put everything together.\n",
    "carbonara.add_task('serve', ['beat eggs', 'cook pancetta', 'colander pasta'])\n",
    "\n",
    "# Let's look at our schedule!\n",
    "carbonara.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "f9ae2a94",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 15,
     "status": "ok",
     "timestamp": 1699916897803,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "-1l1I2T-Wqsf",
    "notebookgrader": {
     "id": "8b4d778756f0150c16f48d52951246c9cec2d89a",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "ba9e8725-401d-4d17-913d-a34352b99654"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Starting by doing: {'dice onions', 'fill pot with water', 'put eggs in bowl', 'dice pancetta', 'put oil and butter in pan'}\n",
       "Completed: dice pancetta\n",
       "Now doing: {'dice onions', 'fill pot with water', 'put oil and butter in pan', 'put pancetta in pan', 'put eggs in bowl'}\n",
       "Completed: fill pot with water\n",
       "Now doing: {'dice onions', 'put pancetta in pan', 'put oil and butter in pan', 'put eggs in bowl', 'bring pot of water to a boil'}\n",
       "Completed: bring pot of water to a boil\n",
       "Now doing: {'dice onions', 'put pancetta in pan', 'put oil and butter in pan', 'put eggs in bowl', 'add salt to water'}\n",
       "Completed: put oil and butter in pan\n",
       "Now doing: {'dice onions', 'add salt to water', 'put pancetta in pan', 'put eggs in bowl'}\n",
       "Completed: dice onions\n",
       "Now doing: {'put pancetta in pan', 'add salt to water', 'put eggs in bowl', 'put onions in pan'}\n",
       "Completed: add salt to water\n",
       "Now doing: {'put pancetta in pan', 'put pasta in water', 'put eggs in bowl', 'put onions in pan'}\n",
       "Completed: put eggs in bowl\n",
       "Now doing: {'put pancetta in pan', 'put pasta in water', 'beat eggs', 'put onions in pan'}\n",
       "Completed: put pasta in water\n",
       "Now doing: {'put pancetta in pan', 'colander pasta', 'beat eggs', 'put onions in pan'}\n",
       "Completed: put pancetta in pan\n",
       "Now doing: {'colander pasta', 'beat eggs', 'put onions in pan'}\n",
       "Completed: beat eggs\n",
       "Now doing: {'colander pasta', 'put onions in pan'}\n",
       "Completed: colander pasta\n",
       "Now doing: {'put onions in pan'}\n",
       "Completed: put onions in pan\n",
       "Now doing: {'cook pancetta'}\n",
       "Completed: cook pancetta\n",
       "Now doing: {'serve'}\n",
       "Completed: serve\n",
       "Now doing: set()"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# And let's finally prepare carbonara!\n",
    "execute_schedule(carbonara)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f13fb2a",
   "metadata": {
    "id": "Qrba88naXKx7",
    "notebookgrader": {
     "id": "efe93c9f446d86f67d048ed822e133b6b6e58e78",
     "readonly": true
    }
   },
   "source": [
    "This is not necessarily the best order of actions to prepare pasta carbonara, but it definitely works as a schedule."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "957e742d",
   "metadata": {
    "id": "dZrkVt32F8Nm",
    "notebookgrader": {
     "id": "5531d1003988ea9df669b07cfe8e7c73d1adcd15",
     "readonly": true
    }
   },
   "source": [
    "**Exercise:** Modify `mark_completed` to raise an `IllegalCompletion` exception if a task is marked completed via a `completed` call, and yet, not all of its prerequisites had been completed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "ca92fbd9",
   "metadata": {
    "executionInfo": {
     "elapsed": 2,
     "status": "ok",
     "timestamp": 1733291392000,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "75dimcRzJBvR",
    "notebookgrader": {
     "id": "5bd3b36e96138be3955a8eb7d8467851d9548f69",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title Checks that `mark_completed` does not mark completed a task whose prerequisites are not all done\n",
    "\n",
    "class IllegalCompletion(Exception):\n",
    "    def __init__(self, t):\n",
    "        self.message = \"Not all prerequisited for %r have been completed\" % t\n",
    "\n",
    "\n",
    "def dependency_scheduler_mark_completed(self, t):\n",
    "    \"\"\"Marks the task t as completed, and returns the additional\n",
    "    set of tasks that can be done (and that could not be\n",
    "    previously done) once t is completed.\"\"\"\n",
    "    # Insert the check below.\n",
    "    ### YOUR SOLUTION HERE\n",
    "    if self.predecessors[t].issubset(self.completed_tasks):\n",
    "        pass\n",
    "    else:\n",
    "        raise IllegalCompletion(t)\n",
    "\n",
    "    self.completed_tasks.add(t)\n",
    "    return {u for u in self.successors[t]\n",
    "            if self.predecessors[u].issubset(self.completed_tasks)}\n",
    "\n",
    "DependencyScheduler.mark_completed = dependency_scheduler_mark_completed"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "54bd4b82",
   "metadata": {
    "id": "R0rHIhPmKgj4",
    "notebookgrader": {
     "id": "d5a7b7cefb9278b0b6dce2e67e05e2107a8f6fe0",
     "readonly": true
    }
   },
   "source": [
    "Let us test this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "c538487b",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 13,
     "status": "ok",
     "timestamp": 1699916897804,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "tp5sVYbnKiax",
    "notebookgrader": {
     "id": "9dc9ddfd165e857d2a38f059a626e91e7f43163f",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: `mark_completed` checks\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "s.add_task('b', ['a'])\n",
    "s.add_task('c', ['a'])\n",
    "s.add_task('d', ['b', 'c'])\n",
    "s.add_task('e', ['a', 'd'])\n",
    "\n",
    "s.mark_completed('a')\n",
    "s.mark_completed('b')\n",
    "raised = False\n",
    "try:\n",
    "    s.mark_completed('d')\n",
    "except IllegalCompletion:\n",
    "    raised = True\n",
    "assert raised\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02a66a41",
   "metadata": {
    "id": "szOgKu26V4wb",
    "notebookgrader": {
     "id": "e5fc5787add2eb5f746e9f6d1263c3c1290af304",
     "readonly": true
    }
   },
   "source": [
    "## Building a Better Execution Engine"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f95be584",
   "metadata": {
    "id": "i5DWfqhdWZVB",
    "notebookgrader": {
     "id": "28d30dcb309fc6317cb432b2710eb74f6b2a515b",
     "readonly": true
    }
   },
   "source": [
    "Let us build a better execution engine for our schedules.  Right now, we have a function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "1a03dfbf",
   "metadata": {
    "executionInfo": {
     "elapsed": 13,
     "status": "ok",
     "timestamp": 1699916897804,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "Smos2oumWe82",
    "notebookgrader": {
     "id": "fead7771c61f1cc89cc157d1bd0d3aae8b983ce7",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def execute_schedule(s, show=False):\n",
    "    s.reset()\n",
    "    in_process = s.available_tasks\n",
    "    print(\"Starting by doing:\", in_process)\n",
    "    while len(in_process) > 0:\n",
    "        # Picks one random task to be the first to be completed.\n",
    "        t = random.choice(list(in_process))\n",
    "        print(\"Completed:\", t)\n",
    "        in_process = in_process - {t} | s.mark_completed(t)\n",
    "        print(\"Now doing:\", in_process)\n",
    "        if show:\n",
    "            s.show()\n",
    "    # Have we done all?\n",
    "    if not s.done:\n",
    "        print(\"Error, there are tasks that could not be completed:\", s.uncompleted)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a1aabbf",
   "metadata": {
    "id": "fznv6hdoWguc",
    "notebookgrader": {
     "id": "64f78a1516142cfa03bb333054cbd508e888f52e",
     "readonly": true
    }
   },
   "source": [
    "We want to wrap these methods into a class, RunSchedule.  This will allow us more flexibility in executing a schedule, as we will be able to specify parameters that guide the execution policy, interrupt and resume the execution, and so on.  \n",
    "An object of class RunSchedule is initialized with a DependencyScheduler.  It then has the following methods:\n",
    "\n",
    "* **reset:** mark all tasks as not completed.\n",
    "* **step:** perform one step in the schedule, completing a single task.\n",
    "* **run:** performs all steps in the schedule, until completion.\n",
    "* **done:** indicates that all tasks have been done.\n",
    "\n",
    "What should these methods return?  _step_ will return the task executed, while _run_ will return the whole list of tasks, in the order in which they were done."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "b80e68c3",
   "metadata": {
    "executionInfo": {
     "elapsed": 12,
     "status": "ok",
     "timestamp": 1699916897804,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "AN8FEYZSWfmG",
    "notebookgrader": {
     "id": "8909857a941cb81551c9eb7b65f8454a7d5b69c5",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class RunSchedule(object):\n",
    "\n",
    "    def __init__(self, scheduler):\n",
    "        self.scheduler = scheduler\n",
    "        self.in_process = None # Indicating, we don't know yet.\n",
    "\n",
    "    def reset(self):\n",
    "        self.scheduler.reset()\n",
    "        self.in_process = None\n",
    "\n",
    "    def step(self):\n",
    "        \"\"\"Performs a step, returning the task, if any, or None,\n",
    "        if there is no step that can be done.\"\"\"\n",
    "        # If we don't know what steps are in process, we get them.\n",
    "        if self.in_process is None:\n",
    "            self.in_process = self.scheduler.available_tasks\n",
    "        if len(self.in_process) == 0:\n",
    "            return None\n",
    "        t = random.choice(list(self.in_process))\n",
    "        self.in_process = self.in_process - {t} | self.scheduler.mark_completed(t)\n",
    "        return t\n",
    "\n",
    "    @property\n",
    "    def done(self):\n",
    "        return self.scheduler.done\n",
    "\n",
    "    def run(self):\n",
    "        \"\"\"Runs the scheduler from the current configuration to completion.\n",
    "        You must call reset() first, if you want to run the whole schedule.\"\"\"\n",
    "        tasks = []\n",
    "        while not self.done:\n",
    "            t = self.step()\n",
    "            if t is not None:\n",
    "                tasks.append(t)\n",
    "        return tasks"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c841033",
   "metadata": {
    "id": "mjRmn1lHdf4l",
    "notebookgrader": {
     "id": "3bb23e220637a3a15c07eaa4cd2ba8ccedc0d207",
     "readonly": true
    }
   },
   "source": [
    "We can run our pasta carbonara with this RunSchedule class:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "792e01cf",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 187,
     "status": "ok",
     "timestamp": 1699916897979,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "0bZmEjNudl2z",
    "notebookgrader": {
     "id": "7a5da2d4863115c6b44571c7cadbf489f5df81b6",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "6e0b6552-a5d6-4ee1-ce3e-dda56213ef96"
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "runner = RunSchedule(carbonara)\n",
    "runner.reset()\n",
    "runner.run()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "56990467",
   "metadata": {
    "id": "FDTr74TjTH3M",
    "notebookgrader": {
     "id": "58634cff5e53bf347f5b2241c45bd69595a91ff1",
     "readonly": true
    }
   },
   "source": [
    "Let us pause for a moment and ask: did we really need to create a new class? Could we not have done the above in the scheduler class?\n",
    "\n",
    "This is debatable.  The idea in keeping the two classes separate is clarity of goals:\n",
    "\n",
    "* The scheduler is concerned with what _can_ be done next.\n",
    "* The runner is concerned with any practical constraint to the execution, and with the choice of _what_, among the possible, is actually done.\n",
    "\n",
    "We will have occasion below to rely on this division of concerns."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a23ad8c7",
   "metadata": {
    "id": "Vig3PqgLXTUV",
    "notebookgrader": {
     "id": "432a2b96feccb223b52689fa81463ffbaf0a060a",
     "readonly": true
    }
   },
   "source": [
    "### Code changes and rotten eggs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a943a8d",
   "metadata": {
    "id": "zwidmSZB07Rj",
    "notebookgrader": {
     "id": "28421fbdd3d5857df64ab025360c1087312a763b",
     "readonly": true
    }
   },
   "source": [
    "#### Code changes\n",
    "\n",
    "Imagine that you need to compile three programs, `a`, `b`, `c`, and then link together the results into `f.out`.   Once this is done, you compile `d` and `e`, and link into `g.out`.  As the last step, you link the two libraries `g.out` and `f.out` together, and produce `h`. You do it once.  Great.  But now you realize that you need to change `b`.  Do you have to start from scratch?\n",
    "\n",
    "You may think, who cares, it's the CPU doing the work, not me.  Fair enough, but there are some large systems that take minutes, dozen of minutes, to compile.  If you are compiling the linux kernel on a low power CPU, it might take hours.  Surely you don't want to redo everything from scratch!  \n",
    "\n",
    "So imagine you have the tasks in an intermediate state, with some being completed (possibly all of them), and some not.  You can now mark one of the tasks as incomplete, to signal you need to do it again.  What is the set of tasks that as a consequence should also be marked incomplete?\n",
    "If you have two tasks $x$ and $y$, with $y$ being a successor to $x$, if $x$ is marked as \"undone\" as it needs to be redone, then also $y$ will need to be redone, as it might use the results of $x$.\n",
    "\n",
    "To implement this, we will perform two modifications.  First, we will endow our scheduler with a _redo_ method, which marks a task and all its successors (and the successors of the successors, and so forth) to be redone -- that is, it _unmarks_ them as done.  We let you implement this; you have already seen how to compute reachability in the graph chapter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "b9d97ac7",
   "metadata": {
    "executionInfo": {
     "elapsed": 2,
     "status": "ok",
     "timestamp": 1733291392190,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "yraxdJcCLDEX",
    "notebookgrader": {
     "id": "c071c8f0206bdc5854cd72fe53be124d1548c7ac",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title Implementation of `redo`\n",
    "\n",
    "def dependency_scheduler_redo(self, t):\n",
    "    \"\"\"Mark the task t, and all its successors, as undone.\n",
    "    Returns the set of successor tasks of t, with t included.\"\"\"\n",
    "    ### YOUR SOLUTION HERE\n",
    "\n",
    "\n",
    "    # tasks_to_redo = {t}  # Start with the initial task to be redone\n",
    "\n",
    "    # for task in list(tasks_to_redo):\n",
    "    #     for successor in self.successors[task]:\n",
    "    #         if successor in self.completed_tasks:\n",
    "    #             tasks_to_redo.add(successor)\n",
    "\n",
    "    # for task in list(tasks_to_redo):\n",
    "    #     for predecessor in self.predecessors[task]:\n",
    "    #         if predecessor in self.completed_tasks:\n",
    "    #             tasks_to_redo.add(predecessor)\n",
    "\n",
    "    # # Remove tasks to be redone from completed tasks\n",
    "    # self.completed_tasks -= tasks_to_redo\n",
    "\n",
    "    # return tasks_to_redo\n",
    "    tasks_to_redo = {t}  # Initialize with the initial task\n",
    "    stack = [t]  # Initialize stack with the initial task\n",
    "\n",
    "    while stack:\n",
    "        current_task = stack.pop()  # Get the current task\n",
    "        for successor_task in self.successors[current_task]:  # Iterate through successors\n",
    "            if successor_task in self.completed_tasks and successor_task not in tasks_to_redo:\n",
    "                tasks_to_redo.add(successor_task)  # Add to tasks_to_redo\n",
    "                stack.append(successor_task)  # Add to stack for further processing\n",
    "\n",
    "    self.completed_tasks -= tasks_to_redo  # Remove tasks_to_redo from completed tasks\n",
    "\n",
    "    return tasks_to_redo\n",
    "\n",
    "\n",
    "DependencyScheduler.redo = dependency_scheduler_redo"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1e620fde",
   "metadata": {
    "id": "ag4GlLAJE2pc",
    "notebookgrader": {
     "id": "85718b66a1f4e3c4467aa7874e5f458bd97dd240",
     "readonly": true
    }
   },
   "source": [
    "Let us test the implementation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "735fd4ac",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 11,
     "status": "ok",
     "timestamp": 1699916897979,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "f4UTvx5gE5mj",
    "notebookgrader": {
     "id": "f39d2e1937e57f6bc0b5b7932095e5ee69bd2fec",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: `redo`\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "s.add_task('b', ['a'])\n",
    "s.add_task('c', ['a'])\n",
    "s.add_task('d', ['b', 'c'])\n",
    "s.add_task('e', ['a', 'd'])\n",
    "\n",
    "s.mark_completed('a')\n",
    "s.mark_completed('b')\n",
    "s.mark_completed('c')\n",
    "assert s.available_tasks == {'d'}\n",
    "s.redo('b')\n",
    "assert s.available_tasks == {'b'}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee78f597",
   "metadata": {
    "id": "VPKwPjzgKMzw",
    "notebookgrader": {
     "id": "669fd51743c6d427d503fa6106b398b2371a5c04",
     "readonly": true
    }
   },
   "source": [
    "Next, we implement a runner that has an additional operation _redo(t)_ for a task t."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "c6ebbff3",
   "metadata": {
    "executionInfo": {
     "elapsed": 11,
     "status": "ok",
     "timestamp": 1699916897979,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "uEHd2SL1OGlR",
    "notebookgrader": {
     "id": "b423c8d536b0a70b8f9103dbc8ccafe7d39a66af",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def run_schedule_redo(self, t):\n",
    "    \"\"\"Marks t as to be redone.\"\"\"\n",
    "    # We drop everything that was in progress.\n",
    "    # This also forces us to ask the scheduler for what to redo.\n",
    "    self.in_process = None\n",
    "    return self.scheduler.redo(t)\n",
    "\n",
    "RunSchedule.redo = run_schedule_redo"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "22bb3b91",
   "metadata": {
    "id": "o4TqfqnqOUpH",
    "notebookgrader": {
     "id": "ad4ee8bd1aea1bda0ac610ebccf00ee57810d33e",
     "readonly": true
    }
   },
   "source": [
    "We can now play with it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "aee23e4f",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 11,
     "status": "ok",
     "timestamp": 1699916897979,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "u98SqlZZOex7",
    "notebookgrader": {
     "id": "962f9f29e39a4381fe39365a67b022315657d951",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "e22a6a87-4b02-40f3-dd32-43294fb79fd5"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dice onions\n",
       "fill pot with water\n",
       "put eggs in bowl\n",
       "dice pancetta\n",
       "bring pot of water to a boil\n",
       "put onions in pan\n",
       "put oil and butter in pan\n",
       "add salt to water\n",
       "put pancetta in pan\n",
       "put pasta in water\n",
       "---> readd salt\n",
       "marking undone: {'add salt to water', 'put pasta in water'}\n",
       "completed: {'dice onions', 'fill pot with water', 'put pancetta in pan', 'put eggs in bowl', 'bring pot of water to a boil', 'dice pancetta', 'put onions in pan', 'put oil and butter in pan'}\n",
       "cook pancetta\n",
       "add salt to water\n",
       "put pasta in water\n",
       "colander pasta\n",
       "beat eggs\n",
       "serve\n",
       "None\n",
       "None\n",
       "None\n",
       "None\n",
       "--->redo dice pancetta\n",
       "marking undone: {'put pancetta in pan', 'cook pancetta', 'serve', 'dice pancetta'}\n",
       "completed: {'dice onions', 'fill pot with water', 'put pasta in water', 'colander pasta', 'put eggs in bowl', 'add salt to water', 'bring pot of water to a boil', 'put onions in pan', 'put oil and butter in pan', 'beat eggs'}\n",
       "dice pancetta\n",
       "put pancetta in pan\n",
       "cook pancetta\n",
       "serve"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "runner = RunSchedule(carbonara)\n",
    "runner.reset()\n",
    "for _ in range(10):\n",
    "    print(runner.step())\n",
    "print(\"---> readd salt\")\n",
    "print(\"marking undone:\", runner.redo(\"add salt to water\"))\n",
    "print(\"completed:\", runner.scheduler.completed_tasks)\n",
    "for _ in range(10):\n",
    "    print(runner.step())\n",
    "print(\"--->redo dice pancetta\")\n",
    "print(\"marking undone:\", runner.redo(\"dice pancetta\"))\n",
    "print(\"completed:\", runner.scheduler.completed_tasks)\n",
    "for t in runner.run():\n",
    "    print(t)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a9d7a8f",
   "metadata": {
    "id": "Ya4rAU0XXKpH",
    "notebookgrader": {
     "id": "7a726afde5354eacec6d33b94ee1e986845877f2",
     "readonly": true
    }
   },
   "source": [
    "You have learned to sequence the order in which to do tasks so as to respect their dependencies.  In the next chapter, we will learn how to also take into account the time it takes for us to do the tasks.  In the meantime, bon appetit, or rather, guten appetit, or rather, buon appetito!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c00d962a",
   "metadata": {
    "id": "C3kVBcs2kDij",
    "notebookgrader": {
     "id": "3a9c36335aa130361cc769ec63b1e7d953d02b45",
     "readonly": true
    }
   },
   "source": [
    "#### Redoing in cooking\n",
    "\n",
    "The act of redoing a cooking step is somewhat different than the act of redoing something in code.  Suppose you cook pasta, unite with it the fried bacon and onions, and then -- terrible mishap -- you unite with it the beaten egg yolks in which one of the eggs is rotten.\n",
    "\n",
    "In code, when one file changes, you only need to redo the things that _depend_ on that file.  In cooking, it is different: even if nothing changed in the bacon, onions, and cooked pasta, once you add to it rotten eggs you have to redo the pasta, bacon, onions, etc, as well, as they have now been contaminated.  The root of the problem is that in a makefile, when you combine two files to compute a result, you do not destroy the original files, whereas in cooking, once you combine foods, you don't have the original foods any longer.  Cooking is like a makefile in which, once you combine files, you immediately delete them.\n",
    "\n",
    "So let us come up with a precise definition of what needs to be redone in cooking, when one of the steps goes bad (the eggs are rotten, you burn the food on the stove, and so on).\n",
    "\n",
    "Initially, we label _redo_ the task that needs redoing.  We then propagate the label according to these two phases:\n",
    "\n",
    "**Phase 1: Forward**\n",
    "Apply the following rule as long as it can be applied:\n",
    "\n",
    "* Consider a task $v$ labeled _redo_. If $u$ is a successor of $v$ and $u$ is completed, then $u$ is also labeled _redo_.\n",
    "\n",
    "**Phase 2: Backward**\n",
    "Apply the following rule as long as it can be applied:\n",
    "\n",
    "* Consider a task $v$ labeled _redo_. If $u$ is a predecessor of $v$, then $u$ is also labeled _redo_ (note that in this case, we are guaranteed that $u$ is completed).\n",
    "\n",
    "The first rule corresponds to a _forward_ pass in the dependency garph; the second rule corresponds to a _backward_ pass in the dependency relation.\n",
    "Once the _redo_ label is propagated, all tasks that are marked _redo_ are changed from completed, to uncompleted.\n",
    "\n",
    "Note that you have to implement _once_ the forward phase, followed by _once_ the backward phase.  Example: you press some lemons, and you use a bit of the juice to make a mayonnaise, and another part to marinate shrimp.  If it turns out that the egg yolk used for the mayonnaise was rotten, you need to press a bit of lemon again, but you do not need to marinate the shrimp once more.\n",
    "\n",
    "We ask you to implement this in code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "d60d5dba",
   "metadata": {
    "executionInfo": {
     "elapsed": 1,
     "status": "ok",
     "timestamp": 1733291392477,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "H6h_r0x1ovLj",
    "notebookgrader": {
     "id": "a4c843fa61c2168f16026da18452aa56e5d11599",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title Implementation of `cooking_redo`\n",
    "\n",
    "def dependency_scheduler_cooking_redo(self, v):\n",
    "    \"\"\"Indicates that the task v needs to be redone, as something went bad.\n",
    "    This is the \"cooking\" version of the redo, in which the redo propagates\n",
    "    to both successors (as for code) and predecessors.\"\"\"\n",
    "    ### YOUR SOLUTION HERE\n",
    "\n",
    "\n",
    "\n",
    "    # self.completed_tasks -=\n",
    "\n",
    "    tasks_to_redo = {v}  # Start with the initial task to be redone\n",
    "\n",
    "    for task in list(tasks_to_redo):\n",
    "        for successor in self.successors[task]:\n",
    "            if successor in self.completed_tasks:\n",
    "                tasks_to_redo.add(successor)\n",
    "\n",
    "    for task in list(tasks_to_redo):\n",
    "        for predecessor in self.predecessors[task]:\n",
    "            if predecessor in self.completed_tasks:\n",
    "                tasks_to_redo.add(predecessor)\n",
    "\n",
    "    # Remove tasks to be redone from completed tasks\n",
    "    self.completed_tasks -= tasks_to_redo\n",
    "\n",
    "    return tasks_to_redo\n",
    "\n",
    "DependencyScheduler.cooking_redo = dependency_scheduler_cooking_redo"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01df733d",
   "metadata": {
    "id": "Kp_-vGeNqaYR",
    "notebookgrader": {
     "id": "fb44e52b8aa74fdaf988544365372451c1751f96",
     "readonly": true
    }
   },
   "source": [
    "Let us check that the code works.  First, a simple example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "548b437b",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 10,
     "status": "ok",
     "timestamp": 1699916897980,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "OH_GGErDqZDj",
    "notebookgrader": {
     "id": "17612f17161ca628ecf3adbbc442f72d2c697c3c",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Basic tests for `cooking_redo`\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "s.add_task('b', [])\n",
    "s.add_task('c', ['a', 'b'])\n",
    "s.add_task('d', ['c', 'a'])\n",
    "s.add_task('e', [])\n",
    "s.add_task('f', ['e'])\n",
    "s.add_task('g', ['f', 'd'])\n",
    "\n",
    "s.mark_completed('a')\n",
    "s.mark_completed('b')\n",
    "s.mark_completed('c')\n",
    "s.mark_completed('d')\n",
    "assert s.available_tasks == {'e'}\n",
    "s.cooking_redo('c')\n",
    "# When we redo c, both its successor d, and predecessors a, b have to be redone.\n",
    "assert s.available_tasks == {'a', 'b', 'e'}\n",
    "assert s.completed_tasks == set()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d11b6c03",
   "metadata": {
    "id": "zFjUHYL_9Rnb",
    "notebookgrader": {
     "id": "d6376a3599c5196db0f3f58acb99fbb0b9093736",
     "readonly": true
    }
   },
   "source": [
    "And now, some slightly more sophisticated tests."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "8e8c5e19",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 10,
     "status": "ok",
     "timestamp": 1699916897980,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "5mE3xhmK9WvW",
    "notebookgrader": {
     "id": "72863d975bc1d1703e7c42e6c586ec73b36009ec",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Advanced tests for `cooking_redo`\n",
    "\n",
    "s = DependencyScheduler()\n",
    "s.add_task('a', [])\n",
    "s.add_task('b', [])\n",
    "s.add_task('c', ['a', 'b'])\n",
    "s.add_task('d', ['c', 'a'])\n",
    "s.add_task('e', [])\n",
    "s.add_task('f', ['e'])\n",
    "s.add_task('g', ['f', 'd'])\n",
    "\n",
    "s.mark_completed('a')\n",
    "s.mark_completed('b')\n",
    "s.mark_completed('c')\n",
    "s.mark_completed('d')\n",
    "s.mark_completed('e')\n",
    "assert s.available_tasks == {'f'}\n",
    "s.cooking_redo('c')\n",
    "# When we redo c, both its successor d, and predecessors a, b have to be redone.\n",
    "assert s.available_tasks == {'a', 'b', 'f'}\n",
    "assert s.completed_tasks == {'e'}\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0e880f47",
   "metadata": {
    "id": "iRjD9H1AOHjr",
    "notebookgrader": {
     "id": "8bce49a02944b986546dc5bfd6ab11c2f970bdb8",
     "readonly": true
    }
   },
   "source": [
    "## And-Or Schedules\n",
    "\n",
    "In the schedules we have seen so far, the dependencies are in _and_ one with the other: if a task $a$ depends on $b, c$, then _both_ $b$ _and $c$ need to be completed before $a$ can be started.\n",
    "It is possible to consider also cases where dependencies are in an _or_ relation: if $a$ depends on $b, c$ in an _or_ way, then it suffices to complete one of $b$ _or_ $c$ before starting $a$.\n",
    "For instance, in our Carbonara Pasta example, it is possible (even though not necessarily advisable) to use shallots in place of onions.\n",
    "In that case, instead of\n",
    "\n",
    "    carbonara.add_task('put onions in pan', ['dice onions'])\n",
    "\n",
    "we could have:\n",
    "\n",
    "    carbonara.add_or_task('put onions in pan', ['dice onions', 'dice shallots'])\n",
    "\n",
    "so that before putting the (now generally named) onions in a pan, we could choose to dice either shallots or onions.\n",
    "\n",
    "Formally, the idea is to endow the Scheduler class with _two_ methods:\n",
    "\n",
    "* `add_and_task(self, t, dependencies)` adds a task `t` with list of dependencies `dependencies`, so that `t` can be done when _all_ of the dependencies are done.  The task `t` is called an AND node in the dependency graph.\n",
    "\n",
    "* `add_or_task(self, t, dependencies)` adds a task `t` with list of dependencies `dependencies`, so that `t` can be done when _at least one_ of the dependencies is done.  The task `t` is called an OR node in the dependency graph.\n",
    "\n",
    "You need to find a way to remember which dependency graph nodes are AND or OR nodes, and you need to implement the properties `done`, `available_tasks`, `uncompleted`, and the method `mark_completed`, to make this class work.\n",
    "Implementing the `show` method is optional; do it if it helps you debug your code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "7a95b1f0",
   "metadata": {
    "executionInfo": {
     "elapsed": 191,
     "status": "ok",
     "timestamp": 1733291392790,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "-B5nn74zi8DU",
    "notebookgrader": {
     "id": "752020858acf4aa8daaa07e21935023d1fac481d",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title `AND_OR_Scheduler` implementation\n",
    "\n",
    "class AND_OR_Scheduler(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        # It is up to you to implement the initialization.\n",
    "        ### YOUR SOLUTION HERE\n",
    "        self.tasks = set()\n",
    "        self.predecessors = defaultdict(set)\n",
    "        self.successors = defaultdict(set)\n",
    "        self.completed_tasks = set()\n",
    "        self.and_tasks = set()\n",
    "        self.or_tasks = set()\n",
    "\n",
    "\n",
    "    def add_and_task(self, t, dependencies):\n",
    "        \"\"\"Adds an AND task t with given dependencies.\"\"\"\n",
    "        ### YOUR SOLUTION HERE\n",
    "        self.tasks.add(t)\n",
    "        self.predecessors[t] = set(dependencies)\n",
    "        self.successors[t] = set()\n",
    "        self.and_tasks.add(t)\n",
    "        for dep in dependencies:\n",
    "            self.tasks.add(dep)\n",
    "            self.successors[dep].add(t)\n",
    "\n",
    "\n",
    "\n",
    "    def add_or_task(self, t, dependencies):\n",
    "        \"\"\"Adds an OR task t with given dependencies.\"\"\"\n",
    "        ### YOUR SOLUTION HERE\n",
    "        self.tasks.add(t)\n",
    "        self.predecessors[t] = set(dependencies)\n",
    "        self.successors[t] = set()\n",
    "        self.or_tasks.add(t)\n",
    "        for dep in dependencies:\n",
    "            self.tasks.add(dep)\n",
    "            self.successors[dep].add(t)\n",
    "\n",
    "    @property\n",
    "    def done(self):\n",
    "        ### YOUR SOLUTION HERE\n",
    "        return self.completed_tasks == self.tasks\n",
    "\n",
    "    @property\n",
    "    def available_tasks(self):\n",
    "        \"\"\"Returns the set of tasks that can be done in parallel.\n",
    "        A task can be done if:\n",
    "        - It is an AND task, and all its predecessors have been completed, or\n",
    "        - It is an OR task, and at least one of its predecessors has been completed.\n",
    "        And of course, we don't return any task that has already been\n",
    "        completed.\"\"\"\n",
    "        ### YOUR SOLUTION HERE\n",
    "        available_tasks = set()  # Initialize an empty set to store available tasks\n",
    "\n",
    "        # Iterate through each uncompleted task\n",
    "        for task in self.tasks - self.completed_tasks:\n",
    "            # Check if the task has no predecessors (it's a starting task)\n",
    "            if not self.predecessors[task]:\n",
    "                available_tasks.add(task)\n",
    "                continue  # Move to the next task\n",
    "\n",
    "            # Check if the task is an AND task and all predecessors are completed\n",
    "            if task in self.and_tasks and self.predecessors[task].issubset(self.completed_tasks):\n",
    "                available_tasks.add(task)\n",
    "\n",
    "            # Check if the task is an OR task and at least one predecessor is completed\n",
    "            elif task in self.or_tasks and any(\n",
    "                predecessor in self.completed_tasks for predecessor in self.predecessors[task]\n",
    "            ):\n",
    "                available_tasks.add(task)\n",
    "\n",
    "        return available_tasks\n",
    "\n",
    "    # self.completed_tasks |= hold\n",
    "\n",
    "    def mark_completed(self, t):\n",
    "        \"\"\"Marks the task t as completed, and returns the additional\n",
    "        set of tasks that can be done (and that could not be\n",
    "        previously done) once t is completed.\"\"\"\n",
    "        ### YOUR SOLUTION HERE\n",
    "        self.completed_tasks.add(t)\n",
    "        return {i for i in self.successors[t] if i in self.available_tasks}\n",
    "\n",
    "    def show(self):\n",
    "        \"\"\"You can use the nx graph to display the graph.  You may want to ensure\n",
    "        that you display AND and OR nodes differently.\"\"\"\n",
    "        ### YOUR SOLUTION HERE\n",
    "        g = nx.DiGraph()\n",
    "        g.add_nodes_from(self.tasks)\n",
    "        g.add_edges_from((u, v) for u in self.predecessors for v in self.successors[u])\n",
    "        nx.draw(g, with_labels=True)\n",
    "        plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df371af1",
   "metadata": {
    "id": "YmxtPvP_Vlc0",
    "notebookgrader": {
     "id": "14b21484975696a58d30011eb817c914d128a30b",
     "readonly": true
    }
   },
   "source": [
    "Let us do some simple tests.  First, for good old AND nodes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "39184b46",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 9,
     "status": "ok",
     "timestamp": 1699916897980,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "5XcET9ukUdQJ",
    "notebookgrader": {
     "id": "6516c80a6070184769e9089ac550b6683923e040",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Simple tests for AND nodes.\n",
    "\n",
    "s = AND_OR_Scheduler()\n",
    "s.add_and_task('a', ['b', 'c'])\n",
    "assert s.available_tasks == {'b', 'c'}\n",
    "r = s.mark_completed('b')\n",
    "assert r == set()\n",
    "assert s.available_tasks == {'c'}\n",
    "r = s.mark_completed('c')\n",
    "assert r == {'a'}\n",
    "assert s.available_tasks == {'a'}\n",
    "r = s.mark_completed('a')\n",
    "assert r == set()\n",
    "assert s.available_tasks == set()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59f2776a",
   "metadata": {
    "id": "gXNMdjSmZR1Q",
    "notebookgrader": {
     "id": "6ce5160f6e10e083fdaed4368ebe92fa99493018",
     "readonly": true
    }
   },
   "source": [
    "Then, some simple tests for OR nodes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "62e205d1",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 9,
     "status": "ok",
     "timestamp": 1699916897980,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "vLJqgaqNV7v4",
    "notebookgrader": {
     "id": "d6008738a3a7d4ce9b92eb540ed51266f166cd3c",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Simple tests for OR nodes.\n",
    "\n",
    "s = AND_OR_Scheduler()\n",
    "s.add_or_task('a', ['b', 'c'])\n",
    "assert s.available_tasks == {'b', 'c'}\n",
    "r = s.mark_completed('b')\n",
    "# Now 'a' becomes available.\n",
    "assert r == {'a'}\n",
    "# But note that 'c' is also available, even if useless.\n",
    "assert s.available_tasks == {'a', 'c'}\n",
    "r = s.mark_completed('a')\n",
    "assert r == set()\n",
    "assert s.available_tasks == {'c'}\n",
    "r = s.mark_completed('c')\n",
    "assert r == set()\n",
    "assert s.available_tasks == set()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9566786c",
   "metadata": {
    "id": "lYPsfBBxEZt-",
    "notebookgrader": {
     "id": "4cb90ffc656b43a34f25ddd206fc65790d5516fb",
     "readonly": true
    }
   },
   "source": [
    "Note that a drawback of this simple solution, as illustrated by the above test case, is that we do not distinguish between the tasks that are useful to do the root task, and the tasks that are useless, that is, not part of a minimal solution.  We simply call them available, as they can be done, even though there is no advantage in doing them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "e6709451",
   "metadata": {
    "cellView": "form",
    "executionInfo": {
     "elapsed": 9,
     "status": "ok",
     "timestamp": 1699916897980,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 480
    },
    "id": "8WUyw5lFBm7B",
    "notebookgrader": {
     "id": "f794e210fd41c0304af1160b91d5404318ff70b0",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Tests with both AND and OR nodes.\n",
    "\n",
    "s = AND_OR_Scheduler()\n",
    "s.add_and_task('a', ['b', 'c'])\n",
    "s.add_or_task('b', ['b1', 'b2'])\n",
    "s.add_or_task('c', ['c1', 'c2'])\n",
    "r = s.mark_completed('b1')\n",
    "assert s.available_tasks == {'b', 'b2', 'c1', 'c2'}\n",
    "r = s.mark_completed('b')\n",
    "assert 'a' not in s.available_tasks\n",
    "r = s.mark_completed('c1')\n",
    "assert 'a' not in s.available_tasks\n",
    "r = s.mark_completed('c')\n",
    "assert 'a' in s.available_tasks\n",
    "\n",
    "s = AND_OR_Scheduler()\n",
    "s.add_or_task('a', ['b', 'c'])\n",
    "s.add_and_task('b', ['b1', 'b2'])\n",
    "s.add_and_task('c', ['c1', 'c2'])\n",
    "r = s.mark_completed('b1')\n",
    "assert s.available_tasks == {'b2', 'c1', 'c2'}\n",
    "r = s.mark_completed('c1')\n",
    "assert s.available_tasks == {'b2', 'c2'}\n",
    "r = s.mark_completed('c2')\n",
    "assert s.available_tasks == {'b2', 'c'}\n",
    "r = s.mark_completed('c')\n",
    "assert 'a' in s.available_tasks\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}