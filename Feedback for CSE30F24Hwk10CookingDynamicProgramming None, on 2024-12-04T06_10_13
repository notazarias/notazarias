{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0b992d92",
   "metadata": {
    "id": "HfiFcAD_BDLs",
    "notebookgrader": {
     "id": "949c201270f24a00dc8e1fc5538aea2640ed65f7",
     "readonly": true
    }
   },
   "source": [
    "# Cooking Times and Dynamic Programming\n",
    "\n",
    "Copyright Luca de Alfaro, 2019.\n",
    "License: [CC-BY-NC-ND](https://creativecommons.org/licenses/by-nc-nd/4.0/)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2fce6481",
   "metadata": {
    "id": "phBpLWvWfC7_",
    "notebookgrader": {
     "id": "073f88419dc4a0fcf5de3629c610af6e7d5a021d",
     "readonly": true
    }
   },
   "source": [
    "In the previous chapter, on a particular run of the scheduler for pasta carbonara, I got:\n",
    "\n",
    "```\n",
    "['dice pancetta',\n",
    " 'fill pot with water',\n",
    " 'put eggs in bowl',\n",
    " 'put pancetta in pan',\n",
    " 'dice onions',\n",
    " 'put oil and butter in pan',\n",
    " 'bring pot of water to a boil',\n",
    " 'add salt to water',\n",
    " 'put pasta in water',\n",
    " 'beat eggs',\n",
    " 'put onions in pan',\n",
    " 'colander pasta',\n",
    " 'cook pancetta',\n",
    " 'serve']\n",
    "```\n",
    "\n",
    "This not only makes little sense; it violates the first axiom of making pasta, which states that pasta must be served as soon as fully cooked.  Above, we take our sweet time to cook pancetta _after_ the pasta has been colandered!\n",
    "Indeed, one of the challenges of true cooking is to ensure that things are ready at exactly the right times.  The pancetta has to be done cooking exactly when the pasta is colandered, so that all is united when it's just hot and right.\n",
    "The difficulty is that it's hard to decide precisely when do we need to start slicing onions, or heating water, to achieve this synchronicity.  \n",
    "We will help by designing a _timed scheduler._\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a93b913",
   "metadata": {
    "id": "9JTLyqOOhe3n",
    "notebookgrader": {
     "id": "cd2368387277d5b271d26765c7d74e1c78f13e2a",
     "readonly": true
    }
   },
   "source": [
    "The idea behind the timed scheduler is to endow each task with an _execution time_.  We specify then that the whole schedule has to be done at time 0, and we then go back and compute when we need to start the various tasks, or rather, when is the last possible moment to start the individual tasks, to be done at time 0.\n",
    "\n",
    "The times at which we start tasks will be negative; if you find it strange to use negative time, you might want to think at it as a countdouwn, where we finish with -3, -2, -1, and at 0, not quite liftoff, but a call that dinner is ready; more prosaic perhaps, but also more commestible."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ebb91654",
   "metadata": {
    "id": "iCwpQi5djMF_",
    "notebookgrader": {
     "id": "efc3ebb03c78b2d7959f58880c79974d1bde22a6",
     "readonly": true
    }
   },
   "source": [
    "### Computing start times for the tasks\n",
    "\n",
    "How do we annotate each task with its starting time?\n",
    "\n",
    "The idea is as follows.  For a task $x$, denote by $t(x)$ its start time, denote by $d(x)$ its duration, and denote by $s(x)$ its set of successors, that is, the set of tasks that depend on $x$ directly.\n",
    "\n",
    "First, consider a task with no successors.  The task can be done last, and so we simply need to set $t(x) = -d(x)$ to ensure we finish at time 0.\n",
    "\n",
    "Second, consider a task $x$ with successors $s(x) = \\{y_1, y_2, \\ldots, y_n\\}$.\n",
    "In order to finish $x$ on time for the start of $y_i$, for $1 \\leq i \\leq n$, it must be $t(x) + d(x) \\leq t(y_i)$.\n",
    "As we wish to start $x$ as late as possible, to be done \"just in time\", $t(x)$ must be the _largest_ value such that $t(x) \\leq t(y_i) - d(x)$, for all $1 \\leq i \\leq n$.\n",
    "Thus, it is easy to see that we must choose\n",
    "\n",
    "$$\n",
    "t(x) = - d(x) + \\min_{y \\in s(x)} t(y) \\; .\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cd25a286",
   "metadata": {
    "id": "pRRKo0-akFTr",
    "notebookgrader": {
     "id": "5f14aca7f16082fbb1c45e3b2fc9e779f88f75bd",
     "readonly": true
    }
   },
   "source": [
    "###An abstract algorithm for starting times\n",
    "\n",
    "All we need to do is to ensure that the constraint\n",
    "\n",
    "$$t(x) = - d(x) + \\min_{y \\in s(x)} t(y)$$\n",
    "\n",
    "holds for all tasks (with the convention that $\\min \\emptyset = 0$).\n",
    "How can we do this?\n",
    "\n",
    "We can solve this following an approach known as _dynamic programming._  If you have a set of elements (in our case, tasks), along with a constraint on the elements (such as our formula for $t(x)$ for a task $x$), you can sometimes treat the constraint as an update rule, rather than an equality. To do so, we start by  setting the start times to be as late as possible, that is, to $-d(x)$.\n",
    "We then consider all task $x$ in turn, and we _update_ the start time of $x$ via:\n",
    "\n",
    "$$t(x) := -d(x)  + \\min_{y \\in s(x)} t(y) \\; .$$\n",
    "\n",
    "Once we cannot perform any update, the constraint will hold for all tasks.\n",
    "\n",
    "Our algorithm can thus be expressed as follows:\n",
    "\n",
    "1.   Set $t(x) = -d(x)$ for all tasks $x$.\n",
    "2.   Repeat:\n",
    ">  For all tasks $x$, do:\n",
    "$\n",
    "t(x) := -d(x)  + \\min_{y \\in s(x)} t(y)\n",
    "$\n",
    "* until no change occurs (that is, until $t(x)$ is unchanged for all tasks $x$).\n",
    "\n",
    "The \"until no change occurs\" above means that we have reached a _fixed point_ of the update rule: the update rule, when applied, causes no change in the values.\n",
    "\n",
    "Informally, the algorithm works because initially we set $t(x) = 0$ for every task, thus setting the start time to be as late as possible; we then anticipate the start time only if we have a good reason to do so, to leave enough time for a dependent task to also execute before time 0."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "432dd10b",
   "metadata": {
    "id": "hnZxF_4jTYDe",
    "notebookgrader": {
     "id": "cdd0c457d04d095f4f75070e52572677fbb40468",
     "readonly": true
    }
   },
   "source": [
    "### Correctness of the algorithm\n",
    "\n",
    "This section is optional, and can be skipped at a first reading.  "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8e7f294",
   "metadata": {
    "id": "B8bEwSnOnim1",
    "notebookgrader": {
     "id": "cedd56cdbfda0d7d42016f4786ff15f1b4ab047a",
     "readonly": true
    }
   },
   "source": [
    "\n",
    "\n",
    "How can we prove precisely that the algorithm works?\n",
    "Denote by $t^*(x)$ the _true_ latest starting time for $x$.  \n",
    "The proof proceeds in the following steps.\n",
    "\n",
    "1.  **Termination:** first, we will prove that the algorithm terminates.\n",
    "2.  **Overapproximation:** Second, we will prove that throughout the algorithm, $t(x)$ is always later than the latest starting time, or $t(x) \\geq t^*(x)$.\n",
    "3.  **Underapproximation:** Then, we show that if the relation $t(x) = - d(x) + \\min_{y \\in s(x)} t(y)$ holds, then we have enough time to do all tasks, that is, $t(x) \\leq t^*(x)$.\n",
    "4.  From 2 and 3 above, we conclude that at the fixpoint we have $t(x) = t^*(x)$, QED.\n",
    "\n",
    "We prove 1, 2, 3  in the following.  Let $D(x)$ be the set of tasks that depend on $x$; of course, $s(x) \\subseteq D(x)$, but $D(x)$ also contains the tasks that depend on $x$ via intermediate tasks.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05d09fee",
   "metadata": {
    "id": "6vl8fv44yM0E",
    "notebookgrader": {
     "id": "dd7024b3a0eb80d742000faa7ed9b5dc44638e31",
     "readonly": true
    }
   },
   "source": [
    "#### Termination\n",
    "\n",
    "The one difficult step consists in proving termination, because, well, the algorithm may actually _not_ terminate!\n",
    "\n",
    "If there are cycles in the dependency graph, the algorithm never terminates.  Consider tasks $a$, $b$, $c$, with $a$ dependent on $b$, $b$ on $c$, and $c$ on $a$; assume that all tasks take 1 second.  If we set $t(a) = 0$, we update then $t(c) = -1$, then $t(b) = -2$, then $t(a) = -3$, and so on and so forth.\n",
    "\n",
    "If there are no cycles in the dependency graph, then every path in the graph is of finite length (finite number of edges), because no node can be repeated along the path.  Let $n(x)$ be the length of the longest dependency path ending at $x$, so that $n(x) = 0$ if no task depends on $x$. We prove by induction that the value of $t(x)$ is determined after at most $n(x)$ iterations of step 2 above.\n",
    "This shows that the algorithm terminates in at most as many iterations of step 2 as there are tasks.\n",
    "\n",
    "Precisely, the inductive assertion is that $t(x)$ does not change after $n(x)$ iterations of the algorithm; the induction is over $n(x)$.\n",
    "\n",
    "For the base case, consider tasks $x$ with no dependents, so with $n(x) = 0$.\n",
    "Initially, we set $t(x) = -d(x)$, and as the set $D(x)$ of successor of $x$ is empty, the update reduces to $t(x) := -d(x)$, which leaves $t(x)$ unchanged.\n",
    "\n",
    "For the induction step, consider a task $x$ with $n(x) = k$.  Obviously, $n(y) < k$ for all $y \\in D(x)$, and by induction hypothesis, the values $t(y)$ of $y \\in D(x)$ are determined after $k-1$ iterations.  At iteration $k$, we set $t(x) := -d(x) + \\min_{y \\in s(x)} t(y)$; from then on, as there will not be any change in the right hand side of the update rule, the value of $t(x)$ will also not change."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81a2922f",
   "metadata": {
    "id": "-TM8LjX3ySTu",
    "notebookgrader": {
     "id": "60d60919aa5070c7cac2e5be326b83158f6e8ef2",
     "readonly": true
    }
   },
   "source": [
    "#### Overapproximation\n",
    "\n",
    "We want to show that for all tasks $x$, we have $t(x) \\geq t^*(x)$.\n",
    "This is proved by induction on the number of iterations of the repeat (step 2) of the algorithm.\n",
    "\n",
    "The base case, for zero iterations, follows because initially we have $t(x) = 0$ and $t^*(x) \\leq 0$.\n",
    "\n",
    "In every subsequent iteration of the algorithm, denote with $t(x)$ the start time of $x$ before the iteration (at the end of the previous iteration), and with $t'(x)$ the start time of $x$ at the end of the iteration.  \n",
    "If $t'(x) \\geq t(x)$, the results follows immediately by induction.\n",
    "\n",
    "Assume that $t'(x) < t(x)$.  Then, there is a task $y \\in s(x)$ such that $t'(x) = -d(x) + t(y)$.\n",
    "By induction hypothesis, we have $t(y) \\geq t^*(y)$, and so\n",
    "\n",
    "$$t'(x) \\geq -d(x) + t^*(y)$$\n",
    "\n",
    "We have $t^*(x) \\leq -d(x) + t^*(y)$, to give enough time for task $x$ to run.\n",
    "This leads to $t'(x) \\geq t^*(x)$, completing the induction case."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6bf5724",
   "metadata": {
    "id": "m_DshIlO-HHI",
    "notebookgrader": {
     "id": "5065d67290d7bd9cec7432f925574b6bf0b610e4",
     "readonly": true
    }
   },
   "source": [
    "#### Underapproximation\n",
    "\n",
    "For the proof of the under-approximation, it helps to define an _update operator_ $A$.\n",
    "Let $\\vec{t}$ be the vector consisting of all starting times.  Then, our rule $t(x) := -d(x) + \\min_{y \\in s(x)} t(y)$ can be written as $\\vec{t} = A(\\vec{t})$, where $A$ is an update operator operating on the vector of start times.\n",
    "\n",
    "The operator $A$ is monotonic, that is, $\\vec{t} \\leq \\vec{u}$ implies $A(\\vec{t}) \\leq A(\\vec{u})$, where the inequalities are interpreted in pointwise fashion.  This is simply because the functions $\\min$ and $+$ are monotonic.\n",
    "\n",
    "Furthermore, let $\\vec{t}_0$ be defined by $t_0(x) = -d(x)$, and let $\\vec{t}_1$ be defined by $t(x) = -d(x) + \\min{y \\in s(x)} t_0(y)$; in other words, let $\\vec{t}_0$ be the initial vector, and $\\vec{t}_1 = A(\\vec{t}_0)$ be the first iterate.  \n",
    "In general, let $\\vec{t}_{n+1} = A(\\vec{t}_n)$ for $n \\geq 0$.\n",
    "Since $\\min{y \\in s(x)} t_0(y) \\leq 0$, we have $\\vec{t}_1 \\leq \\vec{t}_0$,  and thus, $A(\\vec{t}_1) \\leq A(\\vec{t}_0)$, or $\\vec{t}_2 \\leq \\vec{t}_1$.\n",
    "This in turn, again by monotoninicy of $A$, leads to $\\vec{t}_3 \\leq \\vec{t}_2$, so that the sequence $\\vec{t}_0, \\vec{t}_1, \\vec{t}_2, \\ldots$, is monotonically decreasing.\n",
    "In particular, we have that $t_n(x) \\leq - d(x)$ for all $n \\geq 0$.\n",
    "\n",
    "If $t(x) = - d(x) + \\min_{y \\in s(x)} t(y)$ holds for all tasks $x$ at the end of the iterations, then also $t(x) + d(x) \\leq t(y)$ holds for all tasks x and their dependent tasks $y$.\n",
    "Thus, if we started every task $x$ at $t(x)$, we would be able to complete every task $x$ by $t(x) + d(x)$.\n",
    "Since $t(x) + d(x) \\leq 0$, $t(\\cdot)$ is a feasible schedule, and it must be earlier or equal to the latest feasible schedule, so that $t(x) \\leq t^*(x)$ for every task $x$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "84fac3b8",
   "metadata": {
    "id": "yUVIKxgy9N9M",
    "notebookgrader": {
     "id": "412cb3036bfab0b65e2d5729801de75924479eee",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from collections import defaultdict"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9026dd5e",
   "metadata": {
    "id": "SacXTaqvMTDF",
    "notebookgrader": {
     "id": "b9d9fd1a2c4b7c2e0572872264879fadaa88b69a",
     "readonly": true
    }
   },
   "source": [
    "### A naive implementation\n",
    "\n",
    "A naive implementation of the algorithm is as follows."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "349788ae",
   "metadata": {
    "id": "imwpMFJseRYP",
    "notebookgrader": {
     "id": "1406904129d133f5f554e539646b18ea8974f71b",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class Task(object):\n",
    "    \"\"\"We represent a task, with a name, duration, and start time.\"\"\"\n",
    "\n",
    "    def __init__(self, name=None, duration=0.):\n",
    "        assert duration > 0, \"The task duration needs to be positive.\"\n",
    "        self.name = name\n",
    "        self.duration = duration\n",
    "        self.start_time = None # Not known initially.\n",
    "\n",
    "    def __repr__(self):\n",
    "        \"\"\"This is used by our functions before to print tasks.\"\"\"\n",
    "        return \"%s[%f][s=%r]\" % (self.name, self.duration, self.start_time)\n",
    "\n",
    "    def __hash__(self):\n",
    "        \"\"\"We need to define this, so that tasks can be used as keys\n",
    "        to dictionaries.\"\"\"\n",
    "        return hash(self.name)\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        \"\"\"Used for comparisons.\"\"\"\n",
    "        return (self.name == other.name and self.duration == other.duration\n",
    "                and self.start_time == other.start_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "f41f57ee",
   "metadata": {
    "id": "CPkbhrGNjzp_",
    "notebookgrader": {
     "id": "5c2ae0e9c21ab50bf2b74ae541787ec670fa9d03",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class TimedScheduler(object):\n",
    "\n",
    "    def __init__(self):\n",
    "        # Once the tasks are scheduled, they will appear in this list in\n",
    "        # order of increasing start time.\n",
    "        self.tasks = set()\n",
    "        self.predecessors = defaultdict(set) # Not really needed.\n",
    "        self.successors = defaultdict(set)\n",
    "        self.sorted_tasks = None\n",
    "\n",
    "    def add_task(self, t, dependencies):\n",
    "        \"\"\"Adds a task t with given dependencies.\"\"\"\n",
    "        # Makes sure we know about all tasks mentioned.\n",
    "        self.tasks.add(t)\n",
    "        self.tasks.update(dependencies)\n",
    "        # Adds to the predecessors of t the tasks in the dependencies.\n",
    "        self.predecessors[t] = self.predecessors[t] | set(dependencies)\n",
    "        for u in dependencies:\n",
    "            self.successors[u].add(t)\n",
    "\n",
    "    def compute_schedule(self):\n",
    "        \"\"\"Computes a schedule\"\"\"\n",
    "        # Initialization step.\n",
    "        for t in self.tasks:\n",
    "            t.start_time = - t.duration\n",
    "        # Iterations.\n",
    "        # If the graph is acyclic, we can do at most n-1 updates, as n-1 is\n",
    "        # the length of the longest path.  So we try to do n updates, and\n",
    "        # if the n-th update still shows change, we stop with an error,\n",
    "        # reporting that the graph contains a cycle.\n",
    "        for num_iteration in range(len(self.tasks)):\n",
    "            changed = False\n",
    "            for x in self.tasks:\n",
    "                new_time = - x.duration + min([0.] + [y.start_time\n",
    "                                               for y in self.successors[x]])\n",
    "                changed = changed or new_time != x.start_time\n",
    "                x.start_time = new_time\n",
    "            if not changed:\n",
    "                break\n",
    "        assert not changed, \"The graph contains a cycle.\"\n",
    "        self.sorted_tasks = list(self.tasks)\n",
    "        self.sorted_tasks.sort(key = lambda t : t.start_time)\n",
    "\n",
    "    def get_schedule(self):\n",
    "        return self.sorted_tasks"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cfc6aa80",
   "metadata": {
    "id": "JmVYsRxeR6si",
    "notebookgrader": {
     "id": "ba725042032f7d54ccc41aef8462d4b16738a4cd",
     "readonly": true
    }
   },
   "source": [
    "We have now reached the apex of our intellectual achievement: we can finally know when to start the various tasks involved in making pasta carbonara.  Such effort, but such reward, also!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fca3f30f",
   "metadata": {
    "id": "kQUMRJI_fWio",
    "notebookgrader": {
     "id": "6c5c7edc65bf810f7bbe306d49d4b5ce039af21a",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tcarbonara = TimedScheduler()\n",
    "\n",
    "# Let's define the tasks first.\n",
    "t_onions = Task('dice onions', 2.)\n",
    "t_pancetta = Task('dice pancetta', 10.)\n",
    "t_oilbutter = Task('put oil and butter in pan', 1.)\n",
    "t_pan = Task('cook pancetta', 35.)\n",
    "\n",
    "t_fill = Task('fill pot with water', 1.)\n",
    "t_boil = Task('bring water to a boil', 10.)\n",
    "t_salt = Task('add salt to water', 1.)\n",
    "t_pasta = Task('cook pasta', 13.)\n",
    "\n",
    "t_eggs = Task('put eggs in bown', 2.)\n",
    "t_beat = Task('beat eggs', 1.)\n",
    "\n",
    "t_serve = Task('serve pasta', 2.)\n",
    "\n",
    "# First, the part about cooking the pancetta.\n",
    "tcarbonara.add_task(t_onions, [])\n",
    "tcarbonara.add_task(t_pancetta, [])\n",
    "tcarbonara.add_task(t_oilbutter, [])\n",
    "tcarbonara.add_task(t_pan, [t_onions, t_pancetta, t_oilbutter])\n",
    "\n",
    "tcarbonara.add_task(t_fill, [])\n",
    "tcarbonara.add_task(t_boil, [t_fill])\n",
    "tcarbonara.add_task(t_salt, [t_boil])\n",
    "tcarbonara.add_task(t_pasta, [t_salt])\n",
    "\n",
    "tcarbonara.add_task(t_eggs, [])\n",
    "tcarbonara.add_task(t_beat, [t_eggs])\n",
    "\n",
    "tcarbonara.add_task(t_serve, [t_beat, t_pasta, t_pan])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "380a8b43",
   "metadata": {
    "id": "vjw5fzJfSMsX",
    "notebookgrader": {
     "id": "56015075f7bd349fd2c7bb9291260b705fa69c6b",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tcarbonara.compute_schedule()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "2722c62a",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 14,
     "status": "ok",
     "timestamp": 1696034443591,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 420
    },
    "id": "-TMcmvDiS5Fd",
    "notebookgrader": {
     "id": "a5980e5997f67de5d7a011be4640b950556e09f6",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "a1f19469-d1e1-44f7-b32e-f75a5b60aa37"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dice pancetta : -47.0\n",
       "dice onions : -39.0\n",
       "put oil and butter in pan : -38.0\n",
       "cook pancetta : -37.0\n",
       "fill pot with water : -27.0\n",
       "bring water to a boil : -26.0\n",
       "add salt to water : -16.0\n",
       "cook pasta : -15.0\n",
       "put eggs in bown : -5.0\n",
       "beat eggs : -3.0\n",
       "serve pasta : -2.0"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "for t in tcarbonara.get_schedule():\n",
    "    print(t.name, \":\", t.start_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "643793ed",
   "metadata": {
    "id": "KZ-adUnmTxos",
    "notebookgrader": {
     "id": "ddd88b8403881c65ddb0f822a59c6b76a6e84e4e",
     "readonly": true
    }
   },
   "source": [
    "Let us check that this will not run forever in case of loops."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "34795b01",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 10,
     "status": "ok",
     "timestamp": 1696034443591,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 420
    },
    "id": "5oFeJ4nWTK-W",
    "notebookgrader": {
     "id": "67f0f350ea51fd92c6f03023d111416a4e9e76f0",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "07014f95-643b-44de-a1e1-1c545314ae46"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Detected a loop"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ta = Task('a', 1.)\n",
    "tb = Task('b', 1.)\n",
    "tc = Task('c', 2.)\n",
    "s = TimedScheduler()\n",
    "s.add_task(ta, [tb])\n",
    "s.add_task(tb, [tc])\n",
    "s.add_task(tc, [ta])\n",
    "try:\n",
    "    s.compute_schedule()\n",
    "except AssertionError:\n",
    "    print(\"Detected a loop\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77c18e2d",
   "metadata": {
    "id": "3rKmZB3IkXko",
    "notebookgrader": {
     "id": "1a599bfb0476db84676ee326c263452a034eb3f8",
     "readonly": true
    }
   },
   "source": [
    "### An efficient implementation of the algorithm\n",
    "\n",
    "Let us consider again the scheduling method of our TimedScheduler class."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "4f8c8b68",
   "metadata": {
    "id": "0xG7d0VMkili",
    "notebookgrader": {
     "id": "1334b6e961a08ac5434ef7555e1263be50e7354a",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def compute_schedule(self):\n",
    "    \"\"\"Computes a schedule\"\"\"\n",
    "    # Initialization step.\n",
    "    for t in self.tasks:\n",
    "        t.start_time = - t.duration\n",
    "    # Iterations.\n",
    "    # If the graph is acyclic, we can do at most n-1 updates, as n-1 is\n",
    "    # the length of the longest path.  So we try to do n updates, and\n",
    "    # if the n-th update still shows change, we stop with an error,\n",
    "    # reporting that the graph contains a cycle.\n",
    "    for num_iteration in range(len(self.tasks)):\n",
    "        changed = False\n",
    "        for x in self.tasks:\n",
    "            new_time = - x.duration + min([0.] + [y.start_time\n",
    "                                           for y in self.successors[x]])\n",
    "            changed = changed or new_time != x.start_time\n",
    "            x.start_time = new_time\n",
    "        if not changed:\n",
    "            break\n",
    "    assert not changed, \"The graph contains a cycle.\"\n",
    "    self.sorted_tasks = list(self.tasks)\n",
    "    self.sorted_tasks.sort(key = lambda t : t.start_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e58c5b42",
   "metadata": {
    "id": "r48lIowqkqKV",
    "notebookgrader": {
     "id": "dff2c96842bc077e5f1f7d9d10524af869673d87",
     "readonly": true
    }
   },
   "source": [
    "This implementation is correct, but it does waste quite a bit of unnecessary work.  For a task $x$, we note that the start time $t(x)$ of $x$ changes only when the start time of some successor of $x$ has changed.\n",
    "Thus, we can obtain amore efficient algorithm by propagating change, updating the starting time of a task only when the starting time of some of its successors changed.\n",
    "\n",
    "To this end, we maintain a _changed_ set, which keeps track of the tasks whose starting times have changed.\n",
    "Let $L$ be the set of tasks that have no successors; these are the tasks that can be done last.\n",
    "Initially, we set $t(x) = -d(x)$ for $x \\in L$, and $t(x) = 0$ otherwise;\n",
    "we also set _changed_ to $L$.\n",
    "Then, we iteratively pick a task $x$ in _changed_, and for all its predecessors $y$, we set $t(y) = min\\{t(y), -d(y) + t(x)\\}$; if this update changes the value of $t(y)$, we put $y$ in _changed_.\n",
    "The process continues until there is no task in _changed_, so that all changes have been propagated.\n",
    "\n",
    "The algorithm can be written as follows."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "299c5543",
   "metadata": {
    "id": "2gzripRxqEzG",
    "notebookgrader": {
     "id": "ad909d39f1815dcfec372968d81bf04306919d30",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def fast_compute_schedule(self):\n",
    "    \"\"\"Computes a schedule for a timed scheduler.\"\"\"\n",
    "    # Initialization step.\n",
    "    for t in self.tasks:\n",
    "        t.start_time = - t.duration\n",
    "    changed = {x for x in self.tasks if len(self.successors[x]) == 0}\n",
    "    while len(changed) > 0:\n",
    "        x = changed.pop()\n",
    "        for y in self.predecessors[x]:\n",
    "            new_start_time = min(y.start_time, -y.duration + x.start_time)\n",
    "            if new_start_time < y.start_time:\n",
    "                changed.add(y)\n",
    "                y.start_time = new_start_time\n",
    "    self.sorted_tasks = list(self.tasks)\n",
    "    self.sorted_tasks.sort(key = lambda t : t.start_time)\n",
    "\n",
    "TimedScheduler.fast_compute_schedule = fast_compute_schedule"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "ef1990da",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 6,
     "status": "ok",
     "timestamp": 1696034443775,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 420
    },
    "id": "hjbM8w6isMl5",
    "notebookgrader": {
     "id": "aaeee27f1f6f541608fa88f7fc1f930c765bd2b0",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "88f7e77b-195d-4f2e-ebbc-ecf96f94c8be"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dice pancetta : -47.0\n",
       "dice onions : -39.0\n",
       "put oil and butter in pan : -38.0\n",
       "cook pancetta : -37.0\n",
       "fill pot with water : -27.0\n",
       "bring water to a boil : -26.0\n",
       "add salt to water : -16.0\n",
       "cook pasta : -15.0\n",
       "put eggs in bown : -5.0\n",
       "beat eggs : -3.0\n",
       "serve pasta : -2.0"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tcarbonara.fast_compute_schedule()\n",
    "for t in tcarbonara.get_schedule():\n",
    "    print(t.name, \":\", t.start_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0502d5f",
   "metadata": {
    "id": "lY8qUcFSs6PK",
    "notebookgrader": {
     "id": "e9d1ced1493fc620f419582bce4b701ee8ad640b",
     "readonly": true
    }
   },
   "source": [
    "Let us check that the two schedules computed are indeed the same."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "92a7ac19",
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "executionInfo": {
     "elapsed": 5,
     "status": "ok",
     "timestamp": 1696034443775,
     "user": {
      "displayName": "Luca de Alfaro",
      "userId": "08154392717664554862"
     },
     "user_tz": 420
    },
    "id": "bDAWgAPws_6e",
    "notebookgrader": {
     "id": "b4560fb1b235e16e911f71d1e494c79ac0f0dc4a",
     "is_solution": false,
     "is_tests": false,
     "readonly": true
    },
    "outputId": "2117a74f-1702-4804-f01b-2a56b76447cc"
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tcarbonara.compute_schedule()\n",
    "# We need to produce a static dictionary: the schedule is formed\n",
    "# by tasks with a .start_time defined, and if we call the scheduler\n",
    "# one more time, these .start_time will be modified.\n",
    "d1 = {t.name: t.start_time for t in tcarbonara.get_schedule()}\n",
    "tcarbonara.fast_compute_schedule()\n",
    "d2 = {t.name: t.start_time for t in tcarbonara.get_schedule()}\n",
    "d1 == d2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a77fed40",
   "metadata": {
    "id": "VXZ3N8ch4nqq",
    "notebookgrader": {
     "id": "9a6410b235199ba25c8c4aaecb5409e8ee12a2f8",
     "readonly": true
    }
   },
   "source": [
    "Writing two implementations of the same algorithm, one simple, the other efficient, and testing them by checking that they give the same results, is a useful and common testing technique."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aec64e83",
   "metadata": {
    "id": "UnDUNMXl4E5W",
    "notebookgrader": {
     "id": "b3e457a600cbdc7910754bb229d2f00a6708111a",
     "readonly": true
    }
   },
   "source": [
    "**Exercise:** the fast_compute_schedule method does not check for loops.  Modify it so that it terminates with an assertion error if the dependency graph contains a loop.  There are various ways in which this can be done, but one of the simplest is as follows.  This is a rough idea; you will need to take care of some corner cases (the tests will help).\n",
    "\n",
    "If there is a loop, the algorithm will keep updating the starting times of the tasks in the loop, so that the starting times will become smaller and smaller.\n",
    "If $X$ is the set of all tasks, clearly the worst case for a task $x$ is that all others have to be done before it, in which case $t(x) = - \\sum_{x \\in X} d(x)$.  So if you ever assign a starting time to a task that is _smaller than_  $- \\sum_{x \\in X} d(x)$, there must be a loop.\n",
    "\n",
    "Note that this relies on the assumption that all tasks have strictly positive durations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "7a635bf8",
   "metadata": {
    "executionInfo": {
     "elapsed": 3,
     "status": "ok",
     "timestamp": 1733292596564,
     "user": {
      "displayName": "Azarias Ashenafi",
      "userId": "07661282689053385655"
     },
     "user_tz": 480
    },
    "id": "qRh5yGI_QB32",
    "notebookgrader": {
     "id": "5c38d91cd9fb2b7b0197ad1955fd0f7e9cd0e5f4",
     "is_solution": true,
     "is_tests": false,
     "readonly": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#@title Definition of `fast_compute_schedule` that checks for loops\n",
    "\n",
    "class DependencyLoop(Exception):\n",
    "    pass\n",
    "\n",
    "def safe_fast_compute_schedule(self):\n",
    "    \"\"\"Computes a schedule for the TimedScheduler.  Raises DependencyLoop\n",
    "    if the dependency graph contains a loop.\"\"\"\n",
    "    ### YOUR SOLUTION HERE\n",
    "\n",
    "    # compute_schedule(self)\n",
    "\n",
    "\n",
    "    # try:\n",
    "\n",
    "    # # This check is likely redundant now and may need to be adjusted\n",
    "    # if self.sorted_tasks[0].start_time < -sum([t.duration for t in self.tasks]):\n",
    "    #     raise DependencyLoop()\n",
    "\n",
    "    try:\n",
    "        compute_schedule(self)\n",
    "    except AssertionError as e:\n",
    "        if \"The graph contains a cycle.\" in str(e):\n",
    "            raise DependencyLoop()  # Raise DependencyLoop if it is\n",
    "        else:\n",
    "            raise\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "TimedScheduler.fast_compute_schedule = safe_fast_compute_schedule"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13d41b85",
   "metadata": {
    "id": "4Kijmo7Kf-Dv",
    "notebookgrader": {
     "id": "7ce323d2475dcddbd5ae8fb2c500e6f996d711ca",
     "readonly": true
    }
   },
   "source": [
    "As usual, let us test this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "5eb415f6",
   "metadata": {
    "cellView": "form",
    "id": "44CyvXM-gAna",
    "notebookgrader": {
     "id": "ba4d3e0509978e8fcdf2f02c34132cfd574f8677",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: Tests with loop\n",
    "\n",
    "# First, a graph consisting only of a loop.\n",
    "ta = Task('a', 1.)\n",
    "tb = Task('b', 1.)\n",
    "tc = Task('c', 2.)\n",
    "s = TimedScheduler()\n",
    "s.add_task(ta, [tb])\n",
    "s.add_task(tb, [tc])\n",
    "s.add_task(tc, [ta])\n",
    "loop = False\n",
    "try:\n",
    "    s.fast_compute_schedule()\n",
    "except DependencyLoop:\n",
    "    loop = True\n",
    "assert loop, \"Loop should be true\"\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "ab87b3c4",
   "metadata": {
    "cellView": "form",
    "id": "CzQBEb6RiC4M",
    "notebookgrader": {
     "id": "efbf705a2593624bc799b91ed9a60c585c4fda1a",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 5,
     "readonly": true,
     "test_points": 5
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 5/5 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 5 points: More tests with loop\n",
    "\n",
    "# Then, a more complex example with a loop.\n",
    "ta = Task('a', 1.)\n",
    "tb = Task('b', 1.)\n",
    "tc = Task('c', 2.)\n",
    "td = Task('d', 4.)\n",
    "te = Task('e', 3.)\n",
    "s = TimedScheduler()\n",
    "s.add_task(ta, [tb, td])\n",
    "s.add_task(tb, [tc])\n",
    "s.add_task(tc, [ta])\n",
    "s.add_task(td, [])\n",
    "s.add_task(te, [tb])\n",
    "loop = False\n",
    "try:\n",
    "    s.fast_compute_schedule()\n",
    "except DependencyLoop:\n",
    "    loop = True\n",
    "assert loop, \"Loop should be true\"\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "4f4df6a4",
   "metadata": {
    "cellView": "form",
    "id": "RC34dUiRkxAo",
    "notebookgrader": {
     "id": "eb0515a12bec786c2fb78201d67e2607d4ebc02d",
     "is_solution": false,
     "is_tests": true,
     "points_earned": 10,
     "readonly": true,
     "test_points": 10
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<b>Tests passed, you earned 10/10 points</b>"
      ]
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "text/plain": []
     },
     "execution_count": null,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tests 10 points: Tests without loop\n",
    "\n",
    "# An example without a loop.\n",
    "ta = Task('a', 1.)\n",
    "tb = Task('b', 1.)\n",
    "tc = Task('c', 2.)\n",
    "td = Task('d', 4.)\n",
    "te = Task('e', 3.)\n",
    "s = TimedScheduler()\n",
    "s.add_task(ta, [tb, td])\n",
    "s.add_task(tb, [tc])\n",
    "s.add_task(tc, [td])\n",
    "s.add_task(td, [])\n",
    "s.add_task(te, [tb])\n",
    "loop = False\n",
    "try:\n",
    "    s.fast_compute_schedule()\n",
    "except DependencyLoop:\n",
    "    loop = True\n",
    "assert not loop\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c3ce540",
   "metadata": {
    "id": "Ya4rAU0XXKpH",
    "notebookgrader": {
     "id": "a4f11d7b587f92b89342f4ff4a09c7337a4691cc",
     "readonly": true
    }
   },
   "source": [
    "## Epilogue\n",
    "\n",
    "Scheduling is a complex problem, with many variants.  Consider for instance our timed scheduling problem: it models only partially how one can cook.  For instance, people generally cannot slice two things at once: if there's only one person, some tasks, such as slicing, become mutually exclusive.  One may also have limitations on how many things can be cooked at the same time.  These are known, in general, as resource constraints on a schedule.  Schedules can have other types of constraints too: particular tasks may be able to be started only after predetermined times, and so forth.\n",
    "For the two problems we have seen, scheduling with dependencies, and with duration constraints, efficient optimal solutions are known.\n",
    "For complex scheduling problems, it is often the case that such efficient solutions are not available, and one must write algorithms that search for a solution, often with the help of heuristics."
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}